\newsection{Simulation et erreurs}


\subsection{Erreurs}
Si la simulation VHDL a permis de valider le bon fonctionnement théorique du projet Cursor, l'installation réelle sur la 
carte a fait apparaître des contraintes techniques liées directement au matériel.
Ces différences montrent bien qu'entre le code informatique et le circuit physique, il existe des réalités de terrain que seule la pratique permet de découvrir.
Ces divergences s'expliquent par plusieurs phénomènes physiques et logiques:
\begin{enumerate}
    \item Glitches
    \item PWM
    \item Latches
\end{enumerate}


\subsubsection{Glitches}

Lors de la simulation du projet des glitches ont apparu sur des signaux.
Le glitch résulte d'un défaut de synchronisation entre les signaux d'entrée (fig. \ref{fig:05_glitches}).

\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{pictures/05/05_glitches.png}
    \caption{Glitches: signal accept avec un glitch encerclé en rouge \cite{ind}}
    \label{fig:05_glitches}
\end{figure}

L'élimination des aléas s'effectue par une resynchronisation de l'étage de sortie via une bascule D.
En intégrant le signal accept dans une bascule D cadencé par le clock, le système n'échantillonne la valeur que lors des fronts actifs.

Cette méthode permet de filtrer les pics parasites transitoires, car le glitch, se produisant entre deux fronts d'horloge, 
n'est jamais capturé par le registre.

\subsubsection{PWM}

Au niveau de la \acrshort{PWM} le gros problem est liée à la vitesse minimale.
Au début du projetvla \acrshort{PWM} ne fonctionnait paa parce que la 
vitesse minimale était de 1 sur 255, cela donnait une puissance trop basse pour bouger le moteur (voir chapitre \ref{subsub:Vitesse minimale} pour les détailles sur ce sujet).

\subsubsection{Latches}

Une attention particulière a dû être portée à l'inférence de latches.
Ces verrous matériels apparaissent lorsque la logique \acrshort{VHDL} n'est pas exhaustive.
Contrairement à la simulation qui peut masquer ce comportement, les latches créent des chemins asynchrones instables sur FPGA, 
rendant le comportement des FSM erratique. La solution a été de mettre par défaut des valeurs dans la FSM.

Un autre problème au niveau des latches était que le logiciel de programmation de l'\acrshort{FPGA} voyait pas de variation dans les bascules des 
registres, donc au lieu de les créer comme éléments de mémoire, le logiciel les imposait comme des 1 et 0 logiques.