\newsection{Description des blocs}

Ce chapitre se focalise sur la description des différentes blocs, pour voir leur contenu de manière détaillée, consulter les annexes \ref{sec:tablesAttachments}.

\subsection{Button manager}

Le bloc \texttt{buttonManager} reçoit en entrée les signaux des 4 boutons, \texttt{restart}, \texttt{go1}, \texttt{go2} et \texttt{button4} renommée 
\texttt{B1}, \texttt{B2}, \texttt{B3}, \texttt{B4} respectivement et les envois directement sur le bus de sortie \texttt{ButtonInfo} à 4 bits. 

Le rôle de ce bloc est de regrouper les 4 signaux des boutons en un bus qui diminue le nombre d'entrée dans 
d'autres blocs (figure \ref{fig:04_button_manager}).
Ce bloc servait aussi à bloquer tout usage des boutons lors que le moteur tournait.
Cette sécurité a dû être retiré à cause du \ref{sub:Bouton 4}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/buttonmanager/04_button_manager.png}
    \caption{Logique du bloc "buttonManager"}
    \label{fig:04_button_manager}
\end{figure}

\subsection{Main controller}

La figure \ref{fig:04_main_controller_out} montre le bloc \texttt{mainController} avec  tous ses inputs et outputs.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/04_main_controller_out.png}
    \caption{Inputs et outputs de "mainController"}
    \label{fig:04_main_controller_out}
\end{figure}

Les inputs sont :
\begin{itemize}
    \item \texttt{motorOn}: signal de l'état du moteur.
    \item \texttt{enableMvt}: signal d'arrêt provenant de l'état des capteurs.
    \item \texttt{button}: un bus contenant l'information de l'état des signaux des boutons (4 bits).
    \item \texttt{absolutePosition}: position actuelle du chariot (18 bits).
    \item \texttt{reg1In}: bus de lecture du registre 1 (18 bits).
    \item \texttt{reg2In}: bus de lecture du registre 2 (18 bits).
    \item \texttt{clock} et \texttt{reset}: signal du clock et reset initial.
\end{itemize}

Les outputs sont :
\begin{itemize}
    \item \texttt{reg1Enable}: signal enable qui permet d'écrire dans le registre 1.
    \item \texttt{reg2Enable}: signal enable qui permet d'écrire dans le registre 2.
    \item \texttt{reg1Out}: bus transportant la valeur à enregistrer dans le registre 1.
    \item \texttt{reg2Out}: bus transportant la valeur à enregistrer dans le registre 2.
    \item \texttt{goalPosition}: position-but que le chariot doit atteindre (bus 18 bits).
    \item \texttt{enableMotor}: signal qui dit au bloc motorControl d'arrêter le moteur (position final atteint).
    \item \texttt{rotation}: sens de rotation (0=avant, 1=arrière).
    \item \texttt{modeManual}: un signal qui passe le programme en mode manuel.
    \item \texttt{leds\_test}: un bus disponible pour tester le fonctionnement du programme lors de la mise en service (non utilisé à la fin du projet).
    \item \texttt{lcd\_display}: un bus utilisé pour contrôler l'affichage du \acrshort{LCD}.
\end{itemize}

Le bloc regroupe les suivantes sous-blocs:
\begin{itemize}
    \item \hyperref[subsub:Rotation Sous]{\texttt{Rotation\_Sous}}.
    \item \hyperref[subsub:Bloc ButtonControlFSM]{\texttt{ButtonControlFSM}}.
    \item \hyperref[subsub:Countdown counter]{\texttt{Counter 28 bits} pour le countdown du bouton 4}.
\end{itemize}

 A regarder en annexe pour voir la mise en place des sous blocs énuméré ci-dessus.

Particularité:
\begin{itemize}
    \item Un transformateur est utilisé pour convertir le bus \texttt{button4counter} de type \texttt{unsigned} en \texttt{std\_ulogic\_vector} (figure \ref{fig:04_transformator}).
    \item Une bascule-E est utilisé pour éliminer les \hyperref[subsub:Glitches]{glitches} du signal \texttt{side} et pour seulement lire la valeur de la première opération du bloc \texttt{Add/Sous}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/buttonCOntrol/04_transformator.png}
    \caption{Bloc mainController, transformateur unsigned \myarrow std\_ulogic\_vector}
    \label{fig:04_transformator}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/buttonCOntrol/04_glitch_flipflop.png}
    \caption{Bascule "E" pour "glitches"}
    \label{fig:04_glitch_flipflop}
\end{figure}

\subsubsection{Rotation Sous}

Le bloc \texttt{rotation\_Sous} a en entrée les bus \texttt{absolutePosition} et \texttt{goalPosition} à 18 bits et le signal de sortie \texttt{CntOut1}.

Le bloc prend la position actuel(\texttt{absolutePosition}) donnée par le \hyperref[subsub:Compteur de position]{compteur absolu} est soustrait à la
position d'arrivée (\texttt{GoalPosition}). 
Pour cela le concept d'un \hyperref[sub:Additionneur à propagation de report]{additionneur à propagation de retour} et le complément à deux est utilisé (figure \ref{fig:04_rotation_sous}). 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/rotationSous/04_rotation_sous.png}
    \caption{Logique du bloc "Rotation\_Sous}
    \label{fig:04_rotation_sous}
\end{figure}

La valeur de \texttt{CurrentPosition} est inversée puis additionner à \texttt{Goalposition}. Il faut aussi additionner 1, 
donc le premier bit du bus \texttt{cnt} est initialisé à 1(figure \ref{fig:04_1_initialisation}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pictures/04/mainController/rotationSous/04_1_initialisation.png}
    \caption{Initialisation à 1 dans le bloc Rotation\_Sous}
    \label{fig:04_1_initialisation}
\end{figure}

La valeur de la soustraction n'est pas utilisée dans son entièreté, seulement le 19ème bit de la soustraction 
\texttt{[cnt(18)]} est utilisé (figure \ref{fig:04_rotsous_19bit}). Il permet de savoir si la position actuelle est plus grande que la 
position d'arrivée en regardant si le résultat de la soustraction est positif ou négatif. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/rotationSous/04_rotsous_19bit.png}
    \caption{Rotation\_Sous, transfère du bit 19}
    \label{fig:04_rotsous_19bit}
\end{figure}

La logique du bloc \texttt{Sous\_1bit} se base sur un soustracteur de base.
Cependant la logique a été réduit pour ne seulement calculer la retenue de sortie (figure \ref{fig:04_rotsous_simplified}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/rotationSous/04_rotsous_simplified.png}
    \caption{Bloc de soustraction simplifié}
    \label{fig:04_rotsous_simplified}
\end{figure}

\subsubsection{Bloc ButtonControlFSM}

La figure \ref{fig:04_buttonCOntrol_out} montre le bloc \texttt{ButtonControlFSM}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/mainController/buttonCOntrol/04_buttonCOntrol_out.png}
    \caption{Bloc ButtonControlFSM avec ses inputs et outputs}
    \label{fig:04_buttonCOntrol_out}
\end{figure}

Les inputs de base sont les mêmes que ceux énuméré dans le chapitre du \texttt{mainController} (\ref{sub:Main controller}).

Les inputs supplémentaires du bloc sont :
\begin{itemize}
    \item \texttt{Side}: signal provenant du bloc \hyperref[subsub:Rotation Sous]{\texttt{Rotation\_Sous}}.
    \item \texttt{Button4counter}: un bus (28 bits) qui contient une valeur utilisée pour savoir combien de temps le bouton 4 est maintenu.
\end{itemize}

Les outputs supplémentaires sont :
\begin{itemize}
    \item \texttt{Enablebutton4load}: un enable qui réinitialise le compteur à 28 bits à 0.
    \item \texttt{Enablebutton4count}: un enable qui actionne le comptage du compteur à 28 bits.
    \item \texttt{enableSideChange}: un enable qui permet de lire seulement la première opération du bloc \hyperref[subsub:Rotation Sous]{Rotation\_Sous}.
\end{itemize}

Le bloc \texttt{buttonControlFSM} à 2 parties : 
\begin{itemize}
    \item La partie demandée dans le cahier des charges.
    \item Une deuxième partie qui gère toutes les options supplémentaires. Celle-ci complète la première partie, voir chapitre \ref{sec:Fonctions supplémentaires}.
\end{itemize}

En annexe se trouve la FSM du bloc \texttt{buttonControlFSM} dans son intégrité.
La figure \ref{fig:04_buttonControl_FSM} montre la partie de la \acrshort{FSM} dédie à la gestion des fonctions obligatoires 
selon le cahier des charges (\ref{sub:Fonctions et fonctionnement})

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{pictures/04/mainController/buttonCOntrol/04_buttonControl_FSM.png}
    \caption{Partie obligatoire de la FSM, color coded}
    \label{fig:04_buttonControl_FSM}
\end{figure}

LA FSM est construite en 5 parties :
\begin{itemize}
    \item La partie jaune: l'initialisation.
    \item La partie rouge: restart.
    \item La partie verte: position 1.
    \item La partie orange: position2.
    \item La partie violette: limite.
\end{itemize}

 Pour simplifier la compréhension de la FSM un diagramme regroupant l'idée général du fonctionnement de 
 la \acrshort{FSM} est montré dans l'image \ref{fig:04_buttonControl_FSM_diagram}. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{pictures/04/mainController/buttonCOntrol/04_buttonControl_FSM_diagram.png}
    \caption{Button control FSM, diagramme de fonctionnement}
    \label{fig:04_buttonControl_FSM_diagram}
\end{figure}

Dès l'alimentation du système, la FSM effectue la phase d'initialisation.
Les valeurs des positions 1 et 2 sont écrites dans les registres 1 et 2 respectivement, et le compteur pour l'option 
supplémentaire est mis à 0. Rien ne se passe tant que le bouton \textit{restart} n'est pas appuyé.

Quand le bouton \textit{restart} est actionné, la FSM donne une rotation par défaut de 1, une position 
de fin (\texttt{111111111111111111}) et l'autorisation de bouger le moteur (\textit{enableMotor}).
Dès que soit le capteur s'active ou \texttt{motorOn} passe à 0, la FSM sait que le chariot se trouve à la position initiale (\textit{reset}).

À ce stade, il est possible de soit appuyer sur le bouton \textit{go1} ou \textit{go2}.
La rotation se calcule de la même manière dans les deux cas.
La seule différence est que si \textit{go1} est actionné, la position d'arrivée est mémorisée dans le registre 1.
Pour \textit{go2}, c'est l'inverse (mémorisation dans le registre 2). Dès que le signal \texttt{motorOn} passe à 0, la FSM sait que 
le chariot est arrivé à sa destination. Il est donc possible d'actionner à nouveau l'un des 2 boutons (autre que celui utilisé précédemment) 
pour recommencer un déplacement.

Une sécurité supplémentaire a été ajoutée.
Si l'un des deux capteurs s'actionne pendant un déplacement vers la position 1 ou 2, la FSM passe à l'état \textit{limite}.
Le moteur s'éteint et seul le bouton \textit{restart} peut être actionné.




\subsection{Motor control}
La figure \ref{fig:04_motor_control_outside} montre le bloc \texttt{motorControl}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pictures/04/motorControl/04_motor_control_outside.png}
    \caption{Bloc motorControl - inputs et outputs}
    \label{fig:04_motor_control_outside}
\end{figure}

Les inputs sont:
\begin{itemize}
    \item \texttt{goalPosition}: position-but que le chariot doit atteindre (bus 18 bits).
    \item \texttt{enableMotor}: signal qui dit au bloc de commencer à bouger le moteur.
    \item \texttt{rotation}: sens de rotation du moteur (0=avant, 1=arrière).
    \item \texttt{enableMvt}: signal qui dit au bloc d'arrêter le moteur(limites atteintes).
    \item \texttt{modeManual}: mode manuel ou automatique (explication dans le chapitre \ref{sec:Fonctions supplémentaires}).
    \item \texttt{encoderA} et \texttt{encoderB}: signaux de l'encodeur pour la mise à jour de la position.
    \item \texttt{clock} et \texttt{reset}: signal de clock et reset initial.
\end{itemize}

Les outputs sont:
\begin{itemize}
    \item \texttt{Side1} et \texttt{Side2}: signaux pour bouger le moteur (voir \ref{sub:Moteur et control du moteur (pont en H)} pour plus d'infos).
    \item \texttt{positionCounter}: position actuelle du chariot (bus 18 bits).
    \item \texttt{motorOn}: signal d'activation du moteur.
    \item \texttt{testOut}: bus pour allumer les LEDs (utilisé pour débogage au début, bus 2 bits).
\end{itemize}

Le but de ce bloc est de bouger le curseur en fonction des informations qui arrivent par le bloc \texttt{mainController}. Il renvoie au bloc 
\texttt{mainController} la position actuelle du chariot et l'état du moteur (allumé ou éteint) pour que le \texttt{mainController} sache quand envoyer des 
nouvelles instructions et puisse calculer le sens de rotation en fonction de la position-but.

Les blocs internes (visable dans l'annexe) sont:
\begin{itemize}
    \item \texttt{ChangeDetector}: Logique pour détecter le changement d'état de l'encodeur.
    \item \texttt{relCounterPWM}: compteur relatif pour la gestion de la vitesse.
    \item \texttt{itératiCounter}: nom pas trop descriptif, compteur de position absolue.
    \item \texttt{AddSous}: Logique pour calculer la position où le chariot commence à décélérer.
    \item \texttt{motorFSM}: bloc qui gère l'état du moteur (arrêté, accélération, vitesse constante, décélération).
    \item \texttt{PWMGenerator}: Générateur du signal \acrshort{PWM} pour bouger le moteur.
    \item \texttt{ledPowerFSM}: Machine d'état pour allumer les LEDs en fonction de la puissance appliquée au moteur.
    \item \texttt{alleLEDBusCreator}: Logique pour mettre le bus dels leds à 8 bits ensemble avec le bus de leds de débogage de la \acrshort{FSM} à 2 bits.
\end{itemize}

\subsubsection{Change detector}
Le but de ce bloc est de générer un signal à 1 bit qui sera utilisé comme "enable" pour les compteurs de position absolue et relative.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{pictures/04/changeDetector/04_chagneDetector.png}
    \caption{Logique du bloc change detector}
    \label{fig:04_change_detector}
\end{figure}


La logique montrée dans la figure \ref{fig:04_change_detector} fait en sorte que la de sortie est '1' chaque fois que 
l'état représenté par l'ensemble des signaux \texttt{encoderA} et \texttt{encoderB} change.

Le circuit se  compose de deux détecteurs changement de bit mis ensemble dans un xor. Chaque fois que l'un des deux bits change, la sortie devient '1'.

Le tableau \ref{tab:04_encoder_state} montre les états actuels et futures de l'encodeur (ensemble de A et B).

\begin{table}[ht]
    \centering
    \begin{tabular}{|c c|c c|}
        \hline
        $Q_A$ & $Q_B$ & $Q_A^+$ & $Q_B^+$ \\
        \hline
        0 & 0 & 1 & 0 \\
        0 & 1 & 0 & 0 \\
        1 & 0 & 1 & 1 \\
        1 & 1 & 0 & 1 \\
        \hline
    \end{tabular}
    \caption{État actuel et suivant de l'encodeur}
    \label{tab:04_encoder_state}
\end{table}




\subsubsection{Relatif counter}
Le bloc \texttt{relativCounterPWM} est un compteur itératif avec \texttt{count/decount}, \texttt{loadData} et \texttt{enableLoad}, le but de ce compteur est de générer le signal duty-cycle utilisé dans la modulation de la vitesse du moteur.
Le signal de sortie est en suite envoyé au bloc \texttt{motorFSM}.

La figure \ref{fig:04_rel_counter_PWM} montre les deux blocs contenues dans \texttt{relCounterPWM}: un compteur itératif à 14 bits et un bloc \texttt{rightShifter} qui s'occupe du bit-shift 
du bus en sortie du compteur.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{pictures/04/relCOunterPWM/04_rel_counter_PWM.png}
    \caption{Logique du bloc relCounterPWM}
    \label{fig:04_rel_counter_PWM}
\end{figure}


Pour le choix du nombre de bit-shift voir \ref{subsub:Delta PWM et dimension du bit-shift}, pour la logique du bloc 
voire l'annexe \ref{pdf:right_shifter}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{pictures/04/relCOunterPWM/04_relCounter.png}
    \caption{Boucle FOR pour le compteur relatif}
    \label{fig:04_relativ_counter_for_loop}
\end{figure}

La figure \ref{fig:04_relativ_counter_for_loop} montre la boucle FOR utilisée pour créer le compteur itératif à 14 bits.

\subsubsection{Compteur de position}
Le bloc \texttt{iterativCounter} est un compteur itératif, le but de ce compteur est de garder la position actuelle du chariot.

Ce bloc est le coeur du système vu qu'il s'occupe de la position actuelle du chariot.
Cette position est utilisée dans le bloc de \texttt{motorControl} mais aussi dans le bloc principal 
\texttt{mainController} (aprés une transformation de "unsigned" à "std\_ulogic\_vector").


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{pictures/04/iterativCounter/04_iterativCOunter.png}
    \caption{Compteur de position}
    \label{fig:04_iterativ_counter}
\end{figure}
La figure \ref{fig:04_iterativ_counter} montre l'extérieur du compteur. De plus, il est visible que le signal \texttt{count/decount}, 
c'est-à-dire le signal qui décide si le compteur doit compter ou décompter, est géré par le signal de \texttt{rotation} qui vient du bloc principal \texttt{mainController}.
De cette manière, si le chariot doit avancer, le compteur compte; sinon il décompte.

Un inverseur est utilisé pas ce que au début le compteur fonctionnait à l'envers.

\subsubsection{Position de ralentissement (AddSous)}

Le bloc \texttt{AddSous} a en entrée le bus \texttt{goalPosition} à 18 bits, le bus \texttt{delta} à 18 bits et 
le signal \texttt{rotation} et en sortie le bus \texttt{start} à 18 bits.

Ce bloc a comme objectif de soit additionner ou soustraire à la position d'arrivée la valeur de \texttt{deltaPWM}. Le résultat de l'opération 
est la position absolue du début de la décélération. Il est transmis par le bus \texttt{start} à la \acrshort{FSM} (figure \ref{fig:04_add_sous}).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/addSOus/04_add_sous.png}
    \caption{Logique du bloc "addSous"}
    \label{fig:04_add_sous}
\end{figure}

Pour que ce bloc fonction comme voulu, \hyperref[sub:Additionneur à propagation de report]{un additionneur à propagation de report} est utilisé. Le complément à deux est aussi utilisé 
pour effectuer la soustraction. Le signal \texttt{rotation} permet de sélectionner quelle opération va être faite. Par exemple si \texttt{rotation} = '1' 
le bloc va soustraire \texttt{delta} à \texttt{goalPosition} et inversement va additionner \texttt{delta} à \texttt{goal Position}. Ceci est nécessaire car ce projet 
travaille avec des positions absolues. 

La figure \ref{fig:04_addsous_explication} est un dessin explicatif fictionnel de la réflexion derrière la logique du bloc \texttt{AddSous}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{pictures/04/addSOus/04_addsous_explication.png}
    \caption{Dessin explicatif du fonctionnement de addSous}
    \label{fig:04_addsous_explication}
\end{figure}

\subsubsection{Motor FSM}
Le bloc \texttt{motor FSM} contient un seul sous-bloc, \texttt{motorControlFSM} qui contient la machine d'état dédiée à la gestion du moteur.

La figure \ref{fig:04_motorFSM_outside} montre les inputs et outputs du bloc \texttt{motorFSM}.

En bleu sont encadrées les outputs utilisées pour la gestion du compteur relatif et en rouge pour la gestion du compteur de position.

Le signal \texttt{PWMProportion} correspond au duty cycle du compteur relatif et \texttt{PWMProportion\_OUT} c'est le signal de duty cycle qui est envoyée au bloc \texttt{PWMGenerator}.

\texttt{goalPosition}, \texttt{enableMotor} et \texttt{modeManual} sont des informations qui viennent de \texttt{mainController}; \texttt{startPWMdown} est la position ou le chariot doit commencer à décélérer.

\texttt{absCounter} correspond à la position actuelle du chariot qui vient du compteur de position.

La sortie \texttt{deltaPWM\_18\_bit} est une constante qui correspond à la distance d'accélération et décélération du chariot (voir \ref{subsub:Delta PWM et dimension du bit-shift}).

\texttt{motorOn} c'est le signal envoyé au moteur pour l'allumer ou l'éteindre, ce signal est aussi envoyé au bloc principal \texttt{mainController} pour savoir si le moteur est allumé ou éteint.

\texttt{leds\_test} c'est un bus de 2 bits utilisé pour allumer les LEDs de débogage de la \acrshort{FSM}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pictures/04/motorFSM/04_motorFSM_outside.png}
    \caption{Bloc motorFSM, ses inputs et outputs}
    \label{fig:04_motorFSM_outside}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{pictures/04/motorFSM/04_motorFSM.png}
    \caption{Contenu du bloc motorFSM}
    \label{fig:04_motor_FSM}
\end{figure}

La subdivision en sous-blocs à été faite pour séparer les transformations de type de données
 (\texttt{std\_ulogic\_vector} à \texttt{unsigned} et viceversa) de la logique extérieure.
Comme on le voit dans la figure \ref{fig:04_motor_FSM} les seules autres bloc sont des
 transformateurs et un bloc de constante (\texttt{deltaPWM\_18\_bit}) qui est mis directement en sortie.

Ce bloc de constante au début entrait aussi dans la FSM mais dans la version finale ceci n'est plus nécessaire mais le bloc est quand même resté là.

La constante contenue dans le bloc est \texttt{13'000}. Elle représente la distance à accélérer et décélérer  
(details dans le chapitre \ref{subsub:Delta PWM et dimension du bit-shift}).

La machine d'état du \texttt{motorControlFSM} est visible en entier dans l'annexe \ref{pdf:motor_fsm_logic}, le diagramme dans l'image 
\ref{fig:04_motorFSM_diagram} montre le fonctionnement général simplifié de la \acrshort{FSM}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pictures/04/motorFSM/04_motorFSM_diagram.png}
    \caption{Diagramme du fonctionnement de motorControlFSM}
    \label{fig:04_motorFSM_diagram}
\end{figure}

Au début la machine démarre dans le bloc initialisation, la machine attend que le \texttt{mainControl} envoie le signal \texttt{restart} pour pouvoir 
passer dans la partie \texttt{restart} où le chariot se déplace en arriéré jusqu'au senseur reed de gauche (input \texttt{enableMvt}).

Vu que \texttt{mainController} peut communiquer avec \texttt{motorControl} seulement avec \texttt{rotation}, \texttt{enableMotor} et \texttt{goalPosition}, pour envoyer l'info "restart" 
le \texttt{mainController} envoie la position-but \texttt{111111111111111111} (le maximum possible), le signal \texttt{enableMotor} '1' et \texttt{rotation} = '1' (arrière).

Vu que la position \texttt{111111111111111111} n'existe pas réellement (le chariot ne peut pas aller au-delà du senseur reed de droite), la \acrshort{FSM} du moteur sait que elle doit 
faire le \texttt{restart}.

Une fois que le chariot est en position de \texttt{restart} la machine entre en \texttt{standby}, attendant les nouvelles instructions.

Une instruction arrive quand \texttt{enableMotor} devient '1', la machine d'état commence l'accélération du moteur en chargeant la vitesse minimale sur le compteur relatif, une fois 
que la proportion arrive à 255 la machine passe en vitesse maximale et bloque le "enable" sur le compteur relatif.

Grace à le bloc \texttt{AddSous} (voir \ref{subsub:Position de ralentissement (AddSous)}) la machine sait quand commencer la décélération, la machine donne le signal \texttt{count/decoount} 
au compteur relatif pour le faire décompter, une fois que la proportion arrive à la vitesse minimale la machine entre en "positionnement", elle force la vitesse minimale en sortie sur 
\texttt{PWMProportion\_OUT} et attend que la position actuelle soit égale à la position-but.

Une fois la position atteinte la machine arrête le moteur et retourne en \texttt{standby}.

\subsubsection{PWM Generator}

Le bloc \texttt{PWMGenerator} reçoit en entrée seulement le signal duty cycle\footnote{plus clock et reset} (\texttt{PWMProportion\_OUT}) venant de la \acrshort{FSM} et met en 
sortie le signal de \acrshort{PWM} (\texttt{pwmOut}) qui va au moteur.

Les sous-blocs (figure \ref{fig:04_PWM_generator}) sont un transformateur de fréquence (de 66MHz à 100kHz), un compteur à 8 bits qui génère la dent de scie et un comparateur 
entre le signal duty cycle et la dent de scie.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pictures/04/PWMGenerator/04_PWM_generator.png}
    \caption{Logique interne du bloc PWMGenerator}
    \label{fig:04_PWM_generator}
\end{figure}

Pour la transformation de fréquence, il est nécessaire de diviser la fréquence du clock de 66\,MHz et la utiliser comme signal enable du 
compteur à 8 bits qui génère la dent de scie de 100kHz.

Vu que le compteur a 256 steps, le calcul pour la division de clock est le suivant:

\begin{equation}
    N_{div} = \frac{66MHz}{100kHz * 256} = \frac{66000000}{100000 * 256} \approx 2.58 \rightarrow 3
\end{equation}

Normalement il est impossible de diviser le clock par un nombre qui est pas une puissance de 2, le système utilisé est donc un compteur de 0 à 2 
(3 steps) qui génère un signal enable chaque fois qu'il se trouve à 2.

De cette manière l'enable arrive chaque 3 cycles de clock, donc la fréquence d'enable est de 22MHz et la fréquence de la dent de scie est:
\begin{equation}
    f_{dent \space de \space scie} = \frac{22MHz}{256} \approx 85.9kHz
\end{equation}

La fréquence de 85.9kHz est acceptable vu que le but principal était d'éviter des bruits audibles 
(au-dessus de 20kHz) et de ne pas dépasser les 100kHz pour le switching des mosfets du pont H(\ref{subsub:Explication fréquence 100kHz}).

La table \ref{tab:04_truth_table_0_2} montre le tableau de vérité utilisé pour créer le compteur.

\begin{table}[h]
    \centering
    \begin{tabular}{|c c|c c|}
        \hline
        $Q_1$ & $Q_0$ & $Q_1^+$ & $Q_0^+$ \\
        \hline
        0 & 0 & 0 & 1 \\
        0 & 1 & 1 & 0 \\
        1 & 0 & 0 & 0 \\
        1 & 1 & - & - \\
        \hline
    \end{tabular}
    \caption{Tableau de vérité pour compteur 0-2}
    \label{tab:04_truth_table_0_2}
\end{table}

Les équations du circuit obtenues par le tableau sont les suivantes:

\begin{equation}
    Q_0^+ = D_0 = \overline{Q_0 \oplus Q_1}\\
\end{equation}
\begin{equation}
    Q_1^+ = D_1 = Q_0
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/PWMGenerator/tr66_100/04_tr_66_100.png}
    \caption{Compteur de 0 à 2}
    \label{fig:04_tr_66_100}
\end{figure}

La figure \ref{fig:04_tr_66_100} montre la logique du compteur de 0 à 2.

Le signal enable rentre dans un compteur a 8 bits qui se compose de 8 compteur à 1 bit simples\footnote{Sans la partie de load data et count/decount} 
mis ensemble dans une boucle "FOR" comme montré dans l'image \ref{fig:04_8_bit_counter}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/PWMGenerator/04_8_bit_counter.png}
    \caption{Compteur à 8 bits}
    \label{fig:04_8_bit_counter}
\end{figure}

La sortie du compteur est directement connecté au bloc \texttt{comparator} qui reçoit en entré aussi la proportion de la \acrshort{PWM}.

Son fonctionnement est le même que le bloc \hyperref[subsub:Position de ralentissement (AddSous)]{AddSous}.
La seule différence est qu'il travaille avec 8 bits et pas 18 bits(\ref{fig:04_comparator}). 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/comparator/04_comparator.png}
    \caption{Logique du bloc "comparator"}
    \label{fig:04_comparator}
\end{figure}

À l'extérieur de ce bloc, sur sa sortie, une bascule D à été ajoutée, sa fonction est d'enlever les"glitches" qui se passent pendant la 
soustraction.
Pour avoir plus d'informations sur l'utilisation d'une bascule, voir le chapitre \hyperref[subsub:Glitches]{glitches}.



\subsection{Deux registres}

Les deux blocs \texttt{reg1} et \texttt{reg2} sont des registres. Ils ont en entrée le bus \texttt{data\_in} à 18 bits et le signal 
\texttt{enable} puis en sortie le bus \texttt{data\_out} à 18 bits.

Un registre a le but de mémoriser des informations. 
Par la répétions de 18 bascules E, un pour chaque bit des bus, il possible de mémoriser une valeur quand \texttt{enable} est à '0' 
et de charger une nouvelle valeur quand \texttt{enable} est à '1'.

La figure \ref{fig:04_registres} montre la boucle for avec les bascules E.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{pictures/04/registers/04_registres.png}
    \caption{Circuirt logique des registres}
    \label{fig:04_registres}
\end{figure}

