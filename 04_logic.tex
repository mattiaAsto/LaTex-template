\newsection{Aperçu du projet}

Au début le projet se présente comme dans la figure \ref{fig:04_full_circuit}.

Tous les inputs et outputs nécessaires au fonctionnement du circuit sont connectés au bloc encagé en rouge. Le bloc est vide et doit
être rempli avec des sous blocs qui créent la logique du système.

La partie en jaune est la gestion des input des quatre boutons, avec un bloc "debounce" pour annuler le rebond mécanique du bouton.

Le rectangle bleu continent tous les inputs de la platine du curseur, avec les reed-relais avec un debounce et les trois inputs
de l'encodeur.

Entouré en vert sont tous les outputs pour les 8 LEDs et l'écran LCD, et en violet les trois sorties qui viennent utilisées pour bouger le moteur.

\begin{figure}[H]
    \centering
    \includegraphics[width=.9\linewidth]{pictures/04/full_circuit.png}
    \caption{Extrait du circuit complet (voir pdf complet dans l'annexe nr.\ref{pdf:full_circuit})}
    \label{fig:04_full_circuit}
\end{figure}

La partie de logique en bas à gauche sert a générer le signal \texttt{clock} et le \texttt{reset} initial.

\subsection{Concept de fonctionnement}

L'idée est de créer un bloc de control principal qui envoie des infos concernant le déplacement a un bloc qui contrôle le moteur.

Un bloc de control des boutons fournit l'état des boutons au bloc de control principal.

Un bloc qui lit la valeur des senseurs et voit de quelle direction le moteur bouge est utilisé pour arrêter le moteur dans le cas ou le 
curseur touche un des deux cotées.

Toute cette logique\footnote{Depuis maintenant "logique de haut niveau" ou "top level logic"} est programmée dans le bloc principal 
de la figure \ref{fig:04_full_circuit}.

Chaque bloc décrit peut être composé de nouveaux sous-blocs, jusqu'à arriver à la logique de base qui se compose soit de portes logiques, 
soit d'une \acrshort{FSM} c.a.d une machine d'état.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{pictures/04/top_level_logic.png}
    \caption{Logique de haut niveau}
    \label{fig:04_top_level_logic}
\end{figure}

L'image \ref{fig:04_top_level_logic} montre la logique de haut niveau avec tous ces blocs principaux:
\begin{itemize}
    \item \texttt{buttonControl} \myarrow compréhension des boutons
    \item \texttt{mainController} \myarrow action en fonction des boutons et position
    \item \texttt{motorControl} \myarrow Bouge le moteur en fonction de l'action décidé par \texttt{mainController}
    \item \texttt{register18Bit} (2x) \myarrow sauver de manière dynamique deux positions-but
    \item \texttt{movementEnable} \myarrow gestion stop aux limites du curseur
    \item \texttt{lcdDisplay} et \texttt{lcdController} \myarrow Logique pour écrire dans l'écran \acrshort{LCD} en bas e droite
\end{itemize}

En général le système fonctionne comme suivant:

\begin{enumerate}
    \item Le bloc \texttt{buttonControl} lit les valeurs des boutons et met en sortie un bus a 4 bit.
    \item Le bloc \texttt{main ontroller} reçoit le bus à 4 bit et connaît la position du curseur. Il peut donc fournit des informations pour bouger le chariot, comme la position-but, le sens de rotation et un signal \texttt{enableMotor} qui est utilisé pour dire au bloc du moteur qu'il faut commencer a bouger. 
    \item Le bloc \texttt{motorControl} reçoit les trois informations et bouge en conséquence. En faisant ça il s'occupe d'accélérer et décélérer le moteur. Pendant tout le processus il fait la mise a jour de la position actuelle du chariot.
    \item Une fois que le moteur ne bouge plus le \texttt{mainController} est prêt pour envoyer des nouvelles instructions.
\end{enumerate}

\subsection{Compteurs itératives}
Le gros du système se base sur des compteurs itératives pour gérer les positions et la vitesse du moteur.

Les compteurs se forment de plusieurs compteurs à 1 bit mise en série par un cycle \texttt{FOR} dans \acrshort{VHDL}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{pictures/04/compteurs/1bit_counter.png}
    \caption{Logique de un compteur 1-bit}
    \label{fig:04_1_bit_counter}
\end{figure}

La figure \ref{fig:04_1_bit_counter} montre la logique d'un compteur à 1 bit Il contient une partie qui permet un \texttt{data-load} et une partie pour choisir si compter et décompter.

\subsection{Additionneur à propagation de report}

Les explications suivantes sont inspirée du document de labo "Additionneurs Binaires"\cite{add}.

L'additionneur à propagation de report est une structure arithmétique modulaire. Il repose sur la mise en cascade de plusieurs blocs 
itératifs, où chaque bloc traite les bits de même poids des deux opérandes.

Pour chaque rang \textit{i}, le bloc effectue l'addition de trois entrées: les deux bits de données (\textit{a\textsubscript{i}} et \textit{b\textsubscript{i}}) ainsi que la 
retenue d'entrée (\textit{c\textsubscript{i}}) provenant du rang précédent.

Chaque bloc produit ensuite deux sorties distinctes:
\begin{itemize}
    \item Le bit de somme (\textit{s\textsubscript{i}}): représente le résultat de l'addition.
    \item La retenue de sortie ((\textit{c\textsubscript{i+1}})):  elle est immédiatement transmise au bloc de rang supérieur (\textit{i+1}).
\end{itemize}

La figure \ref{fig:04_add_prop_report} montre le fonctionnement d'un additionneur à propagation de report.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{pictures/04/addReport/04_add_prop_report.png}
    \caption{Fonctionnement d'un additionneur à propagation de report}
    \label{fig:04_add_prop_report}
\end{figure}
